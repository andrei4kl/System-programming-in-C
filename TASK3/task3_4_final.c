
#include <stdio.h>

#define M 20    // количество элементов в первом массиве (допустимо не менее 1 элемента)
#define N 5     // количество элементов во втором массиве (допустимо не менее 1 элемента)

// программа ищет подстроку в строке и выводит в консоль (значение указателя) адрес в строке где встречается совпадение
 

void main(void)
{   
   printf("\n\nStudent: Klyuzhin A.S.\n\n");
   printf("task3_4"); 
  
   char mas1[M]; 
   char mas2[N];
   char* pm1 = (char*)mas1;                 // указатель на нулевой элемент большой строки (на первый массив)
   char* pm2 = (char*)mas2;               // указатель на нулевой элемент искомой подстроки (на второй массив)
   char* p_addr_start = NULL;       // адрес начала совпавшей подстроки внутри большой строки
   unsigned char flag = 0;          // флаг, выставляется в 1, если символы в строках совпали
   unsigned int length_text1 = 0;   // реально используемое количество ячеек массива 1 для хранения первой строки
   unsigned int length_text2 = 0;   // реально используемое количество ячеек массива 2 для хранения искомой подстроки


printf("\n\nEnter the first text (up to %d characters): \n", M );   

while(1)
{   
    *pm1 = getchar();
    length_text1++;

    
    if(('\n' != *pm1))
    {   
        pm1++;
    }
    else
    {   
        *pm1 = '\0';    // заменяем символ перевода строки на символ окончания строки (для дальнейшей адекватной работы printf)
         break;
    }
    if(pm1 < (mas1 + M - 1))
    {

    }
    else
    {
        *pm1 = '\0';    // заменяем символ перевода строки на символ окончания строки (для дальнейшей адекватной работы printf)
        while(getchar() != '\n');   // очищаем буфер потока stdin
        break; 
    }
}

printf("\n\nEnter the second text (up to %d characters): \n", N);   
while(1)
{   
    *pm2 = getchar();   // сохраняем значение из потока в ячейку массива
    length_text2++;

    
    if('\n' != *pm2)
    {   
        pm2++;
    }
    else
    {   
        *pm2 = '\0';    // заменяем символ перевода строки на символ окончания строки (для дальнейшей адекватной работы printf)
         break;
    }
    if(pm2 < (mas2 + N - 1))
    {

    }
    else
    {
        *pm2 = '\0';    // записываем символ конца строки в последнюю ячейку массива (для дальнейшей адекватной работы printf)
        while(getchar() != '\n');   // очищаем буфер потока stdin (когда вводимая строка больше чем размер массива)
        break; 
    }
}


// выводим полученные строки


pm1 = (char*)mas1;      // указываем на начало первого массива (первая строка)
pm2 = (char*)mas2;      // указываем на начало второго массива (искомая подстрока)

// выводим введенные пользователем строки, чтобы убедиться в правильности ввода (выводится строка от начала до символа конца строки \0)
printf("\n\n STRING1: %s", mas1);   
printf("\n\n STRING2: %s", mas2);
printf("\n\n The addresses STRING1: %p\n", mas1);

pm1 = (char*)mas1;  //восстанавливаем значение адреса в указателе на начало первого массива
pm2 = (char*)mas2;  //восстанавливаем значение адреса в указателе на начало второго массива

  while((pm1 < (mas1+length_text1-1))&&((mas2 + length_text2 - pm2) <= (mas1 + length_text1 - pm1)))       // до предпоследнего символа, т.к. последний  это \0 и первая строка все еще больше второй
  {      
    if((*pm2 == *pm1))
    {        
       if((mas2 + length_text2 - pm2)<=(mas1 + length_text1 - pm1))    // проверяем помещается ли остаток подстроки в остаток строки
       { 
         p_addr_start = pm1; 
         flag = 1;
         pm1++; // переходим к следующему элементу в строке
         pm2++; // переходим к следующему элементу в подстроке
         while((1 == flag)&&( pm2 < (mas2 + length_text2 - 1)/* && (pm2 >= mas2)*/))    // пока адрес ячейки меньше максимального в массиве подстроки минус 1 (т.к. последний символ \0)
         {              
            if (*pm2 != *pm1)
            {   
                flag = 0;
            }    
            else
            {
                pm1++; // переходим к следующему элементу в строке
                pm2++; // переходим к следующему элементу в подстроке              
            }

         }
         if(pm2 >= (mas2 + length_text2 - 1))
         {
            pm2 = mas2;   // возвращаем значение указателя к исходному адресу (первому элементу подстроки)
         }
         else{}

       }
       else
       {
          flag = 0; 
       } 
    }
    else
    {
        flag = 0;
        pm2 = mas2; // возвращаемся к первому элементу подстроки
        pm1++;
    }

    if(1 == flag)
    {
        printf("\n\n A match was found for the addresses: %p\n", p_addr_start);     // выводим адрес в строке при каждом совпадении (допускается множественное совпадение)
        pm2 = mas2; // возвращаемся к первому элементу подстроки
    }
    else{}
 
  }

 printf("\n\nThe END.");
}
