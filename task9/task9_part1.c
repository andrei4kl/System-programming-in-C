
#include <stdio.h>  //стандартная библиотека для работы функции printf
#include <unistd.h> //библиотека для работы с системными фызовами open, write, read
#include <fcntl.h>  // определения для параметров управления файлами
#include <string.h> // в этой библиотеке определена функция strlen()
#define FULL_LEN_MY_STR 50      //
void main()
{

char str[FULL_LEN_MY_STR] = "String from file";     // создаю строку с текстом для записи в файл, в конце которой содержится символ конца "\0"
char my_buf[FULL_LEN_MY_STR] = "test_test_test_test_test_test_test_test_test_test";     // создаю массив для чтения из файла (заполняю мусором для отладки)
//printf("\nmy_buf = %s", my_buf);

int fd = open("output.txt", O_RDWR|O_CREAT,0666); // создать файл если не существует и сохранить его дескриптор в переменную fd
                                                   // ключи O_RDWR|O_CREAT означают разрешение на запись и чтение
                                                   // "0666" всем пользователям можно читать из и файла и записывать в него
                                                   // Set-User-ID, Set-Group-ID, sticky bit - не устанавливаю, сбросил в 0
if(fd != -1)    // если нет ошибок при открытии файла, то
{
    write(fd, str, strlen(str)); // записать в файл строку из массива str (функция strlen(str) возвращает количество символов в строке str от начала до символа конца строки)
                                 // символ конца строки не записываем в файл
    //printf("\n strlen(str) = %ld",strlen(str));
    
    //при считывании вместо strlen(str) использую другой способ подсчета записынных байт в файле
    int max = lseek(fd, 0, SEEK_END);   // получаю значение файлового смещения для байта следующего за последним в файле 
                                        // это смещение фактически равно количеству элементов в самом файле (т.к. у первого элемента смещение 0)
    //printf("\nmax:%d", max);
    
    for(int ind = 0; ind < max; ind++)
     {
        lseek(fd, -(1+ind), SEEK_END);    // изменяю файловое смещение при каждом проходе на одну позицию, от конца к началу файла 
                                          // в выражении смещения "-(1+ind)" присутствует единица, т.к. SEEK_END указывает на байт следующий за последним байтам файла,
                                          // т.е. на элемент находящийся вне файла
        read(fd, &my_buf[ind], 1);   // считать из файла 1 байт и записать в ячейку массива
     }
    
    my_buf[max] = '\0'; // записываю символ конца строки в последний байт в массиве, для корректной работы printf
    printf("\nreverse reading from a file: %s\n", my_buf);
    
    
}
else
{
    printf("\nError!\n");
}

close(fd); // закрываем файл

}