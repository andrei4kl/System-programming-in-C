
#include <stdio.h>  //стандартная библиотека для работы функции printf
#include <unistd.h> //библиотека для работы с системными фызовами
#include <sys/types.h>
#include <sys/wait.h>
#define FILE1 "process1" // путь к исполняемому файлу, который необходимо запустить в качестве порожденного процесса
#define FILE2 "process2" // путь к исполняемому файлу, который необходимо запустить в качестве порожденного процесса

void main()
{
    pid_t pid = 0;                    // PID главного просесса (т.е. ID этой программы при запуске)
    pid_t ppid = 0;                   // PPID главноего процесса (т.е. родительский ID относительно этой программы)
    pid_t pid_new_process1 = 0;        // PID порожденного процесса, созданного в ходе выполнения этой программы (получаем в процессе создания процесса)
    pid_t pid_new_process2 = 0;
    int status1 = 0;                 // сохраняем статус завершения работы порожденного процесса (потомка)    
    int status2 = 0;
    pid = getpid();
    ppid = getppid();

    printf("Главный процесс.\nPID = %d, PPID = %d.\n", pid, ppid);
    pid_new_process1 = fork();       // создаю процесс и записываю возвращенное значение(PID, ошибка)
    // т.к. после вызова fork() создается полная копия процесса, в новом процессе будут
    // присутствовать (соответственно выполнятся) все строки кода родительского процесса следующие за системным вызовом fork()
    // чтобы дважды их не выполнять ввожу проверку PID процесса, если PID возвращенный сист. вызовом fork() равен:
    //  0 - это порожденный процесс (находимся в порожденном процессе, т.е. в новом)
    // -1 - ошибка создания нового процесса (находимся в родительском процессе)
    // какое то значение - это PID созданного процесса, но возвращенный родительскому (находимся в родительском процессе)
    
    if(pid_new_process1 == -1)
    {
        printf("Ошибка создания нового процесса(N1).\n");
        
    }
    else if(pid_new_process1 == 0)
     {
        printf("Сейчас мы находимся в порожденном процессе N1.\n");
        execl(FILE1," ",NULL);  // указываю на образ процесса (выполнить файл), а также один неиспользуемый аргумент
    // после вызова execl() образ (код программы) порожденного процесса изменяется и следующий за этим вызовом код из процесса родителя не дублируется в процессе потомка
    // поэтому END выводится один раз
     }
    else
    {
    printf("Создан процесс N1 с PID = %d\n", pid_new_process1);
    pid_new_process2 = fork();  // создаю второй процесс

    if(pid_new_process2 == -1)
    {
        printf("Ошибка создания нового процесса(N2).\n");
    }
    else if(pid_new_process2 == 0)
     {
        printf("Сейчас мы находимся в порожденном процессе N2.\n");
        execl(FILE2," ",NULL);  // указываю на образ процесса (выполнить файл), а также один неиспользуемый аргумент
    // после вызова execl() образ (код программы) порожденного процесса изменяется и следующий за этим вызовом код из процесса родителя не дублируется в процессе потомка
    // поэтому END выводится один раз
     }
    else
    {
    printf("Создан процесс N2 с PID = %d\n, ждем завершения порожденного процесса N2...", pid_new_process2);
    waitpid(pid_new_process2, &status2, 0);

    }

    printf("Ждем завершения порожденного процесса N1...\n");
    waitpid(pid_new_process1, &status1, 0); // добавил ожидание окончания любого (т.к. у меня только один порожденный процесс) порожденного процесса, т.к. если процесс-родитель завершится раньше,
                     // то PPID порожденного процесса будет переопределен системой и мы не увидим в нем PID родителя.
                     // в переменную status сохраняется результат завершения порожденного процесса. 
    }
    printf("Статус завершения порожденного процесса N1 status1 = %d.\n", status1>>8);    // в этом числе закодирована информация о состоянии завершения процесса, её можно интерпретировать используя макросы
    printf("Статус завершения порожденного процесса N2 status2 = %d.\n", status2>>8);    // при этом возвращаемое функцией значение занимает старшие 8 бит, делаю сдвиг чтобы выделить его 
    printf("END\n");

}