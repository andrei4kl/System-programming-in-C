
#include <stdio.h>  //стандартная библиотека для работы функции printf
#include <unistd.h> //библиотека для работы с системными фызовами
#include <sys/types.h>
#include <sys/wait.h>
#define FILE "process5" // путь к исполняемому файлу, который необходимо запустить в качестве порожденного процесса
int main()
{
    pid_t pid = 0;                    // PID главного просесса (т.е. ID этой программы при запуске)
    pid_t ppid = 0;                   // PPID главноего процесса (т.е. родительский ID относительно этой программы)
    pid_t pid_new_process = 0;        // PID порожденного процесса, созданного в ходе выполнения этой программы (получаем в процессе создания процесса)
    int status = 0;                 // сохраняем статус завершения работы порожденного процесса (потомка)    
   
    pid = getpid();
    ppid = getppid();

    printf("Процесс N2.\nPID = %d, PPID = %d.\n", pid, ppid);
    
    pid_new_process = fork();       // создаю процесс и записываю возвращенное значение(PID, ошибка)
    // т.к. после вызова fork() создается полная копия процесса, в новом процессе будут
    // присутствовать (соответственно выполнятся) все строки кода родительского процесса следующие за системным вызовом fork()
    // чтобы дважды их не выполнять ввожу проверку PID процесса, если PID возвращенный сист. вызовом fork() равен:
    //  0 - это порожденный процесс (находимся в порожденном процессе, т.е. в новом)
    // -1 - ошибка создания нового процесса (находимся в родительском процессе)
    // какое то значение - это PID созданного процесса, но возвращенный родительскому (находимся в родительском процессе)
    if(pid_new_process == -1)
    {
        printf("\nОшибка создания нового процесса N5.\n");
    }
    else if(pid_new_process == 0)
     {
        printf("Сейчас мы находимся в порожденном процессе N5.\n");
        execl(FILE," ",NULL);  // указываю на образ процесса (выполнить файл), а также один неиспользуемый аргумент
    // после вызова execl() образ (код программы) порожденного процесса изменяется и следующий за этим вызовом код из процесса родителя не дублируется в процессе потомка
    // поэтому END выводится один раз
     }
    else
    {
    printf("Создан процесс N5 с PID = %d\n", pid_new_process);
    printf("Ждем завершения порожденного процесса N5...\n");
    wait(&status); // добавил ожидание окончания любого (т.к. у меня только один порожденный процесс) порожденного процесса, т.к. если процесс-родитель завершится раньше,
                     // то PPID порожденного процесса будет переопределен системой и мы не увидим в нем PID родителя.
                     // в переменную status сохраняется результат завершения порожденного процесса. 
    }
    printf("Статус завершения порожденного процесса N5 status5 = %d.\n", status>>8); // в этом числе закодирована информация о состоянии завершения процесса, её можно интерпретировать используя макросы
                                                                                     // возвращаемое функцией значение занимает 8 старших бит, выделяю их битовым смещением           
    return 2;      // возвращаю номер процесса                 
}