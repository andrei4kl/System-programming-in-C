
#include <stdio.h>  //стандартная библиотека для работы функции printf
#include <unistd.h> //библиотека для работы с системными фызовами
#include <sys/types.h>
#include <sys/wait.h>
#define FILE1 "process3" // путь к исполняемому файлу, который необходимо запустить в качестве порожденного процесса
#define FILE2 "process4" // путь к исполняемому файлу, который необходимо запустить в качестве порожденного процесса

int main()
{
    pid_t pid = 0;                    // PID главного просесса (т.е. ID этой программы при запуске)
    pid_t ppid = 0;                   // PPID главноего процесса (т.е. родительский ID относительно этой программы)
    pid_t pid_new_process1 = 0;        // PID порожденного процесса, созданного в ходе выполнения этой программы (получаем в процессе создания процесса)
    inpid_tt pid_new_process2 = 0;
    int status1 = 0;                 // сохраняем статус завершения работы порожденного процесса (потомка)    
    int status2 = 0;
        
    pid = getpid();
    ppid = getppid();

    printf("Процесс N1.\nPID = %d, PPID = %d.\n", pid, ppid);
    
    pid_new_process1 = fork();       // создаю процесс и записываю возвращенное значение(PID, ошибка)
    // т.к. после вызова fork() создается полная копия процесса, в новом процессе будут
    // присутствовать (соответственно выполнятся) все строки кода родительского процесса следующие за системным вызовом fork()
    // чтобы дважды их не выполнять ввожу проверку PID процесса, если PID возвращенный сист. вызовом fork() равен:
    //  0 - это порожденный процесс (находимся в порожденном процессе, т.е. в новом)
    // -1 - ошибка создания нового процесса (находимся в родительском процессе)
    // какое то значение - это PID созданного процесса, но возвращенный родительскому (находимся в родительском процессе)
    
    if(pid_new_process1 == -1)
    {
        printf("\nОшибка создания нового процесса(N3).\n");
    }
    else if(pid_new_process1 == 0)
     {
        printf("Сейчас мы находимся в порожденном процессе N3.\n");
        execl(FILE1," ",NULL);  // указываю на образ процесса (выполнить файл), а также один неиспользуемый аргумент
    // после вызова execl() образ (код программы) порожденного процесса изменяется и следующий за этим вызовом код из процесса родителя не дублируется в процессе потомка
    // поэтому END выводится один раз
     }
    else
    {
    printf("Создан процесс N3 с PID = %d\n", pid_new_process1);
    
    pid_new_process2 = fork();  // создаю второй процесс

    if(pid_new_process2 == -1)
    {
        printf("\nОшибка создания нового процесса(N4).\n");
    }
    else if(pid_new_process2 == 0)
     {
        printf("Сейчас мы находимся в порожденном процессе N4.\n");
        execl(FILE2," ",NULL);  // указываю на образ процесса (выполнить файл), а также один неиспользуемый аргумент
    // после вызова execl() образ (код программы) порожденного процесса изменяется и следующий за этим вызовом код из процесса родителя не дублируется в процессе потомка
    // поэтому END выводится один раз
     }
    else
    {
    printf("Создан процесс N4 с PID = %d\n", pid_new_process2);
    printf("Ждем завершения порожденного процесса N4...\n");
    waitpid(pid_new_process2,&status2,0);

    }

    printf("Ждем завершения порожденного процесса N3...\n");
    waitpid(pid_new_process1, &status1,0); // добавил ожидание окончания любого (т.к. у меня только один порожденный процесс) порожденного процесса, т.к. если процесс-родитель завершится раньше,
                     // то PPID порожденного процесса будет переопределен системой и мы не увидим в нем PID родителя.
                     // в переменную status сохраняется результат завершения порожденного процесса. 
    }
    printf("Статус завершения порожденного процесса N3 status3 = %d.\n", status1>>8); // возвращаемое функцией значение занимает 8 старших бит в переменной, поэтому делаю сдвиг, чтобы вывести только моё значение
    printf("Статус завершения порожденного процесса N4 status4 = %d.\n", status2>>8);
    
    return 1;   // в качестве возвращаемого значения использую номер созданного процесса
   
}