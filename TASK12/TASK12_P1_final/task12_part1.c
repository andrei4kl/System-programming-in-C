
#include <stdio.h>  //стандартная библиотека для работы функции printf
#include <unistd.h> //библиотека для работы с системными фызовами
#include <pthread.h>
//#include <sys/types.h> 
#include <sys/wait.h>       // wait()

void main()
{
    char mass[4] = "Hi!";
    char buffer[10];    // буффер для считывания информации из канала
    pid_t process_id;   // идентификатор порождаемого процесса
    int pipe_fd[2];     // массив для хранения файловых дескрипторов канала
    int status;       // переменная для сохранения статуса завершения дочернего процесса

    pipe(pipe_fd);   // создаем канал и сохраняем дескрипторы чтения в pipe_fd[0] и записи в pipe_fd[1]

    process_id = fork();    // создаем процесс (разветвляем)

    if(process_id > 0)      // если это процесс родителя, то
    {
        close(pipe_fd[0]);  // закрываем дескриптор канала на чтение
        // тут пишем в канал информацию
        write(pipe_fd[1], mass, 3); // файловый дескриптор, адрес в памяти где лежат данные, количество записываемых в канал байт
        wait(&status);             // ожидание завершения дочернего процесса (он у нас только один)
        printf("Конец!\n");
    }
    else
    {
        printf("Вошли в дочерний процесс.\n");
        //dup2(pipe_fd[0],0); // подменяем STDIN на pipe_fd[0] для этого процесса
        //close(pipe_fd[0]);  // закрываем дескриптор канала на чтение
        close(pipe_fd[1]);  // закрываем дескриптор канала на запись
               
        read(pipe_fd[0], buffer, 3);    // считываем ровно столько сколько записали, т.к. не использую проверку статуса выполнения команды read 
            
        printf("Дочерний процесс считал из канала %s\n", buffer);
        printf("Выходим из дочернего процесса.\n");
        
    }

    
    
}

